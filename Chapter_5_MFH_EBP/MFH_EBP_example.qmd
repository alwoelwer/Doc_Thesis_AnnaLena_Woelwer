---
title: "Chapter 5: Empirical Best Prediction in Multivariate Fay-Herriot Models"
author: "Anna-Lena Wölwer"
format: html
editor: visual
---

## Description

The theoretical basis of the following examples is given in Chapter 5 of the dissertation *Model-Based Prediction and Estimation Using Incomplete Survey Data* by *Anna-Lena Wölwer*, which is available as an open-source document here *XXXXX insert OPUS link here*.

This folder contains files `MFH_gen_dat_m3.R` and `MFH_EBP_fitting.R`, both of which contain executable functions which are illustrated in the following. `MFH_gen_dat_m3.R` contains functions for generating data according to MMFH models. `MFH_fitting.R` contains a function for fitting a MMFH model (parameter estimation, predictions, analytical MSE estimates).

## Libraries

For the examples, we use the following libraries.

```{r}
library(fOptions)
library(mvtnorm)
```

## Short overview of the R codes in this folder

```{r}
source(paste0(getwd(), "/MFH_gen_dat_m3.R"))
```

The file comes with two functions for generating data according to a MMFH model with $m=3$ dependent variables (therefore the *\_m3* in the name). The code contains comments on the inputs of the functions.

Function `f_prep_MFH_m3` is used to generate all quantities which are typically considered to be fixed in model-based small area simulation studies like the matrix of auxiliary information. For a simulation study, we would execute this function only once. The function takes as input all parameters of a multivariate Fay-Herriot model like the fixed effects, the variance components, and the number of domains.

Function `f_gen_MFH_m3` is used to generate all quantities which are typically considered random in model-based small area simulation studies like the random effects and sampling errors. For a simulation study, we would execute this function in each Monte Carlo iteration. The function takes as input all quantities generated by function `f_prep_MFH_m3` as well as the inputs of `f_prep_MFH_m3`.

```{r}
source(paste0(getwd(), "/MFH_fitting.R"))
```

The file contains function `f_MMFH`. The code contains comments on the inputs of the function.

Function `f_MMFH` is used to fit a MMFH model to input data. This includes the estimation of the model fixed effects ($\beta$) and variance components ($\theta$) via Fisher-Scoring, either based on maximum likelihood (ML) or restricted maximum likelihood (REML). Furthermore, based on the parameter estimates, the model returns estimates of the random effects, the synthetic predictions ($X \beta$) and the EBPs. In addition, the MSE estimates are given.

Although in this file we only cover the case of $m=3$ dependent variables, function `f_MMFH` works for an arbitrary number of $m\geq 2$ dependent variables.

## Generate example data

Generate the fixed quantities of a MMFH model including randomly generated auxiliary information (documentation of required inputs in `MFH_gen_dat_m3.R`).

Set input quantities

```{r}
m = 3 # total number of variables of interest, number of dependent variables
D = 100 # total number of domains
v_ref = c(2,3,4) # variances of random effects of the 3 variables
cor_ref = c(.2,.3,.4) # correlations of random effects
v_rer = c(2.5,3.5,4.5) # variances of sampling errors of the 3 variables
cor_rer = c(.15,.25,.35) # correlations of sampling errors
beta = list(c(1.5, 2.5), # list, for each variable: vector of fixed effects
            c(2.3,3.3,4.3),
            c(4.1,3.1,2.1, 2.2))
range_aux = c(10, 100) # range of the uniform distribution from which auxiliary information is sampled from
perc_mis = c(5, 5, 2) # percentage of missing domain information per variable
```

Generate data

```{r}
d_fix <- f_prep_MFH_m3(seed = 56)
names(d_fix)
```

Use `f_gen_MFH_m3` to generate the model information which typically varies between Monte Carlo iterations. That is, the generation of the dependent variables. The function allows to set certain values as missing, input `perc_mis` determines the number of domains for which the survey information of the three dependent variables is missing. Note that in this code the missing dependent variables are non-overlapping. That is, there is maximum one missing dependent variable per domain. This, however, can easily be changed in the code.

```{r}
d_var <- f_gen_MFH_m3( x = d_fix$x,
                        beta = d_fix$beta,
                        V_ud = d_fix$V_ud,
                        V_ed = d_fix$V_ed,
                        seed = 67,
                        verbose = TRUE )
str(d_var)
```

`y_true` are the (according to the model) true values of the dependent variables, `y_obs` are the survey estimates of the dependent variables, `y_mis` are the survey estimates, which we consider to be available, some of which are missing (determined by `perc_mis` in `f_gen_MFH_m3`). The missing mechanism is *missing completely at random* (MCAR).

Have a look at the generated dependent variables.


From the error message, you can see that there are (as we wanted) missing values in the dependent variables. Furthermore, you can play around with the parameters of the data generation and see how the outcomes of the sampling estimates change.

The number of domains with missing values of variables 1, 2, and 3 is

## Example integration

Set some of the function inputs.

```{r}

# ____________________________________________________________________________
# Load data ----
# ____________________________________________________________________________


# Load Gauss-Hermite Weights and Abscissas
gauss_hermite_abscissas_weights <- readRDS("weight_list_normalized_until_n200.RData")


###
### Load some test data
###

(load("test_dat_for_GH.RData"))

# D           Number of domains
# m           Number of dependent variables
# y           Direct estimates (D x m Matrix)
# X_bdiag     Block-diagonal matrix of auxiliary information, dimension: D*m x p
# V_ed        List: Domain-specific Covariance matrices of sampling errors, each list element has dimension m x m
# V_ud_est    Covariance matrix of random effects, estimated from a bivariate FH model, dimension: m x m
# beta_est    Vector of fixed effects, estimated form a bivariate FH model, length: p

# From the test data: calculate, define certain quantities

# Calculate X beta
X_beta_est  <- matrix(X_bdiag %*% beta_est, ncol = m, byrow = TRUE)

# Calculate residuals
residuals   <- y - X_beta_est



# ____________________________________________________________________________
# Apply Gauss-Hermite quadrature ----
# ____________________________________________________________________________

# The approximation of applied to each of the d=1,...,D domains

results <- sapply(1:D, function (d) {
  
  ###
  ### From the model data: Calculate the conditional mean and covariance
  ###
  
  # Calculate the conditional mean
  mu_int2_ebp <- V_ud_est %*% solve(V_ed[[d]] + V_ud_est) %*% as.vector(residuals[d,])

    # calculate the decomposition of the conditional covariance matrix
  Sigma_Int2_ebp <- V_ud_est %*% solve(V_ud_est + V_ed[[d]]) %*% V_ed[[d]]
  # ensure its symmetric
  Sigma_Int2_ebp[1,2] = Sigma_Int2_ebp[2,1]
  Sigma_Int2_ebp_eig       <- eigen(Sigma_Int2_ebp, symmetric = TRUE)
  Sigma_Int2_ebp_eigen_rot <- (Sigma_Int2_ebp_eig$vectors %*% diag(sqrt(Sigma_Int2_ebp_eig$values)))
  
  
  ### 
  ### Get Gauss-Hermite nodes and weights
  ### 
  
  # Choose the number of function evaluations per dimension
  # Choosing gauss_n = 5 results in a total of 25 function evaluations
  gauss_n = 10
  
  # get the corresponding points and weights
  w_tmp <- gauss_hermite_abscissas_weights[[gauss_n]]
  
  # product rule: Set up the grid of points and weights
  idx <- as.matrix(expand.grid(rep(list(1:gauss_n), m)))
  pts <- matrix(w_tmp[idx,1], nrow(idx), m)
  wts <- apply(matrix(w_tmp[idx,2], nrow(idx), m), 1, prod)
  
  # scale and recenter the weights and nodes to the specific distribution
  wts <- wts * (pi^{- m / 2 })
  pts <- sqrt(2) * pts
  pts <- t(Sigma_Int2_ebp_eigen_rot %*% t(pts))
  pts <- sweep(pts, 2, mu_int2_ebp, "+")
  
  
  ### 
  ### Calculate the integral approximation of the unemployment rate
  ### 

  sum(apply(pts, 1, function(x) {
    (X_beta_est[d,][1] + x[1]) / (X_beta_est[d,][1] + x[1] + X_beta_est[d,][2] + x[2])
  }) * wts) 
  
})

str(results)
# results
# contains the approximation of the unemployment rate for the D domains
```
